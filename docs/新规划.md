
---

# 产品规格说明书：基于 Markdown 状态机的确定性开发编排系统

## 1. 产品愿景与核心哲学 (Vision & Core Philosophy)

本产品是一个**“反转控制（Inversion of Control）”**的软件开发编排器。它不直接生成代码，而是作为一个**确定性的工厂管理者**，指挥 **Claude Code**（作为工人）在严格的物理约束下工作。

*   **唯一真理源 (Single Source of Truth):** 文件系统即数据库。所有的业务需求、执行计划、任务状态和运行日志都物理持久化为 **Markdown/文本文件**。TUI 工具无内部隐藏状态，仅作为文件系统的渲染器和自动化执行器。
*   **规划优先 (Plan-First):** 任何代码修改发生前，必须先在磁盘上生成明确的 Markdown 规划文件。**规划阶段本身也由 Claude Code 执行**，但受到 TUI 的严格提示词约束。
*   **状态隔离 (State Isolation):** 利用 PTY（伪终端）技术，每个任务启动独立的 Claude 进程。任务结束即销毁上下文，杜绝长会话导致的“上下文漂移”。

---

## 2. 文件制品协议 (Artifact Protocol)

系统严格维护项目根目录下 `.claude/` 文件夹内的文件结构。这些文件构成了系统的“状态机”。

### 2.0 全局一致性原则 (Consistency Rules)
*   **单写者模型 (Single Writer):** 只有 TUI 允许修改 `.claude/` 内的状态字段（Frontmatter）。人类可以编辑 `Prompt/规划内容`，但不应直接改 `status/*_at/*_by` 等系统字段。
*   **原子写入:** 所有 Markdown/YAML/JSON 更新必须采用“写临时文件 → `fsync` → 原子 `rename` 替换”策略，避免半写入文件被 `notify` 读取导致状态机抖动。
*   **文件锁:** 对同一个 `TASK-*.md` 的状态更新需持有互斥锁（如 `.claude/locks/<task_id>.lock`），防止并发执行器/重试器重复领取任务。

### 2.1 战略层 (Strategy Layer)
**路径:** `.claude/status/ROADMAP.md`
*   **定义:** 项目的最高业务需求文档（Story）。
*   **生成方式:** 人工编写。
*   **Frontmatter 规范:**
    ```yaml
    type: roadmap
    status: active
    current_phase: phase-1_user_auth
    last_updated: "2023-10-27"
    ```
*   **正文内容:** 自然语言描述的 User Stories 和验收标准（Acceptance Criteria）。

### 2.2 契约层 (Contract Layer)
**路径:** `.claude/status/api_contract.yaml`
*   **定义:** OpenAPI/Swagger 规范的**基线**（Baseline）。
*   **生成方式:** 可由 `utoipa` 自动生成，但进入主干前必须形成“锁定版本”（即提交后的基线文件）。
*   **变更规则:** 任意 API 变更必须通过显式任务（例如 `task-xxx_api_contract_update`）更新该文件，并通过 `spectral lint`（以及可选的 breaking-change 检测）。
*   **作用:** 作为质量门控（Quality Gate），所有涉及 API 的任务在验证阶段必须校验该文件。

### 2.3 战术规划层 (Tactical Layer)
**路径:** `.claude/phases/<phase_id>/PHASE_PLAN.md`
*   **定义:** 一个开发里程碑的详细设计图。
*   **生成方式:** **由 Claude Code 读取 `ROADMAP.md` 后生成**。
*   **Frontmatter 规范:**
    ```yaml
    id: phase-1_user_auth
    status: in_progress # [pending, in_progress, completed]
    strategy: sequential # [sequential, parallel]
    dependencies: []
    context_focus: ["src/auth", "src/db"] # 指导 Repomix 打包范围
    ```
*   **正文内容:** 技术实现路径、架构决策记录、涉及的模块列表。

### 2.4 执行原子层 (Atomic Execution Layer)
**路径:** `.claude/phases/<phase_id>/tasks/TASK-<nnn>.md`
*   **定义:** 最小执行单元，对应一个独立的 PTY 会话。
*   **生成方式:** **由 Claude Code 读取 `PHASE_PLAN.md` 后批量生成**。
*   **Frontmatter 规范:**
    ```yaml
    id: task-001_jwt_impl
    type: code_generation # [code_generation, test_generation, refactor]
    status: pending # [pending, running, verifying, needs_review, completed, failed, skipped, blocked]
    context_files: ["src/main.rs", "src/auth.rs"]
    depends_on: [] # 任务级依赖（DAG），元素为 task id
    resources: [] # 互斥资源（如 "repo_write", "src/auth"），用于并行调度时加锁
    verification_cmd: "cargo test --test auth_flow" # 必须包含验证命令
    timeout_sec: 300
    max_retries: 3
    log_path: ".claude/logs/task-001_jwt_impl.log"
    ```
*   **正文内容:**
    1.  **Prompt:** 给 Claude 的具体指令（如“实现 JWT 签名函数”）。
    2.  **Logs:** (由 TUI 自动追加) 执行摘要（关键错误片段 / 最后 N 行）与 `log_path` 指针。

### 2.5 日志与历史 (Logs & History)
为避免 Markdown 体积无限增长，同时保持“文件系统即真理源”的可追溯性：
*   **任务全量日志:** `.claude/logs/<task_id>.log`（包含原始 stdout/stderr，可选保留 ANSI）。
*   **任务 Markdown:** 仅保留摘要（最后 N 行 / 关键错误片段）+ 指向 `log_path` 的链接。
*   **错误历史:** `.claude/status/error_history.json` 记录失败摘要、重试次数、时间戳、hash（用于“同一代码连续失败”判定）。

---

## 3. 核心工作流引擎 (The Workflow Engine)

TUI 基于 `Tokio` 异步运行时构建，核心是一个无限循环的状态机，通过 `notify` 监听文件变更驱动流转。

### 状态与转移 (State & Transitions)
为保证确定性与可恢复性，任务状态仅允许按下述路径流转（未列出的转移一律视为非法并阻断执行）：
*   `pending` → `running` | `skipped` | `blocked`
*   `running` → `verifying` | `failed`
*   `verifying` → `completed` | `needs_review` | `failed`
*   `needs_review` → `completed` | `pending`（调整后重跑） | `failed`
*   `blocked` → `pending`（解除阻塞后） | `skipped`
*   `failed` → `pending`（重试） | `skipped`

### 阶段一：智能规划 (Planning Phase)
**目标:** 将模糊的 `ROADMAP.md` 转化为具体的 `PHASE` 和 `TASK` 文件。

1.  **触发:** 用户在 TUI 中选中 `ROADMAP.md` 并按下 `p` (Plan)。
2.  **上下文构建:** TUI 调用 `tree-sitter` 生成 `repo_map.json`（代码结构图）。
3.  **Claude 调用 (Architect Mode):** TUI 启动 Claude Code 进程：
    *   **Input:** 注入 `repo_map` + `ROADMAP.md`。
    *   **System Prompt:** “你是一个架构师。请不要写代码。请根据需求，输出 `.claude/phases/` 目录下的目录结构和 Markdown 文件，确保 Frontmatter 符合规范。”
4.  **产出:** Claude 直接在磁盘上创建/更新 `PHASE_PLAN.md` 和一系列 `TASK-NNN.md` 文件。
5.  **人工审计:** TUI 刷新显示新生成的文件。此时所有任务状态为 `pending`。用户可编辑 Markdown 调整任务细节。

### 阶段二：驱动执行 (Execution Loop)
**目标:** 自动化执行所有 `pending` 状态的任务。

1.  **扫描与锁定:** TUI 发现 `TASK-NNN.md` 状态为 `pending`，将其 Frontmatter 修改为 `status: running`。
    *   **领取条件:** 只有在满足 `depends_on` 全部为 `completed`，且 `resources` 所需互斥锁可获得时才允许领取。
    *   **去抖与幂等:** `notify` 事件需去抖（debounce），所有状态更新必须幂等（重复应用不改变结果）。
2.  **环境准备:**
    *   TUI 解析 Frontmatter 中的 `context_files`。
    *   调用 `repomix` 打包这些文件为最小上下文包 `context_bundle.xml`。
    *   **上下文边界:** 默认拒绝打包敏感文件（如 `.env`、私钥、token 文件）；对单文件/总包大小设置上限，超限则任务标记 `blocked` 并提示用户收敛 `context_files`。
3.  **Claude 调用 (Builder Mode):** TUI 通过 `portable-pty` 启动子进程：
    ```bash
    cat context_bundle.xml | claude -p "<读取TASK.md中的Prompt并执行>"
    ```
4.  **实时渲染:** PTY 的输出流被 TUI 捕获，在界面右侧终端窗格实时显示（保留颜色）。
5.  **日志持久化:** 任务结束时，TUI 将全量日志写入 `log_path`，并在 `TASK-NNN.md` 中仅追加摘要（去除 ANSI 颜色码）。

### 阶段三：双重验证 (Verification Phase)
**目标:** 确保生成的代码既符合技术规范，又符合业务需求。

1.  **状态流转:** 执行完成后，状态自动变为 `verifying`。

2.  **内环验证 (Technical Check) - 智能语言适配:**
    TUI 根据项目语言自动选择合适的技术检查命令：

    | 语言 | 检测标志 | 技术检查命令 |
    |------|----------|--------------|
    | Rust | `Cargo.toml` | `cargo check && cargo clippy` |
    | Python | `pyproject.toml` / `setup.py` / `requirements.txt` | `ruff check . && mypy .` (若配置存在) |
    | TypeScript | `tsconfig.json` | `tsc --noEmit && eslint .` |
    | JavaScript | `package.json` (无 tsconfig) | `eslint .` |
    | Go | `go.mod` | `go build ./... && go vet ./...` |
    | Java (Maven) | `pom.xml` | `mvn compile -q` |
    | Java (Gradle) | `build.gradle` | `gradle build -x test` |

    *   **语言检测优先级:** 按上表顺序检测，首个匹配的标志文件确定语言。
    *   **自定义覆盖:** 可在 `.claude/config.yaml` 中配置 `tech_check_cmd` 覆盖默认命令。
    *   **调用 Codex Review** - 使用 `codex exec` 命令进行自动化代码审查。
    *   Codex 输出格式: `VERDICT: PASS|WARN|FAIL`
    *   (若涉及 API) 执行 `spectral lint .claude/status/api_contract.yaml`。

3.  **外环验证 (Business Check):**
    *   执行 Frontmatter 中定义的 `verification_cmd` (如 `cargo test`)。

4.  **决策逻辑 (基于 Codex Verdict):**
    *   **Codex PASS + verification_cmd 成功:** 更新 Markdown 为 `status: completed`。
    *   **Codex FAIL 或 verification_cmd 失败:** 更新为 `status: failed`。TUI 自动读取错误信息，将摘要追加到任务 Markdown，并指向全量日志。
    *   **Codex WARN + verification_cmd 成功:** 默认更新为 `status: needs_review`（或由 `.claude/config.yaml` 中 `warn_policy` 配置为自动完成），并在任务摘要中记录警告要点。

---

## 4. TUI 界面规格 (Interface Specification)

界面使用 `Ratatui` 库实现立即模式渲染，分为三栏布局：

| 区域 | 组件名称 | 功能描述 |
| :--- | :--- | :--- |
| **左栏** | **State Navigator** (状态导航树) | 渲染 `.claude/` 目录树。使用颜色映射 Markdown 状态 (🔴Failed, 🟡Running, 🟢Completed, ⚪Pending)。 |
| **中栏** | **Artifact Editor** (制品编辑器) | 显示当前选中 Markdown 的内容。支持基础编辑（利用 Vim 键位）。 |
| **右栏** | **Execution Terminal** (执行终端) | 利用 `tui-term` 显示当前活跃 PTY 的输出。底部显示进度条和系统资源占用。 |

---

## 5. 关键技术实现细节 (Implementation Details)

### 5.0 Schema 校验与 Lint (Schema & Lint)
为避免手工编辑或模型输出导致制品不可解析：
*   所有制品 Frontmatter 均需通过严格 schema 校验（缺字段/未知字段/非法枚举值直接阻断执行）。
*   规划阶段（Architect Mode）输出文件后，TUI 必须先做 lint 再展示给用户进入执行循环。

### 5.1 "Headless" Claude 集成
为了让 Claude Code 能够被 TUI 编排，我们不使用它的交互模式，而是大量使用其 CLI 的管道能力。
*   **Prompt 注入:** 使用 `-p` 参数传递明确指令，防止 Claude 进入会话等待用户输入。
*   **输出解析:** 虽然 TUI 主要依靠文件系统变化来判断结果，但也监控 stdout 中的特定标记（如 "COMPLETED"）来作为冗余信号。

### 5.2 看门狗机制 (Watchdog)
为了防止 Claude 陷入死循环或网络超时：
*   每个 `running` 状态的任务由 `tokio::time::timeout` 包装。
*   默认超时时间为 300秒（可在 Frontmatter 中覆盖）。
*   超时触发时，TUI 发送 `SIGKILL` 强制杀掉 PTY 子进程，并将任务标记为 `Failed (Timeout)`。

### 5.3 顾问模式 (Advisor Mode) - Claude Code 决策指导
当任务状态变为 `failed` 时，用户可按 `a` 键呼叫 Advisor。

*   **实现方式:** TUI 启动一个**新的 Claude Code PTY 进程**（非交互式）
*   **输入构建:**
    1. 读取失败任务的 Markdown 文件（包含 Prompt 和错误日志）
    2. 读取相关的 `context_files` 内容
    3. 构建顾问 Prompt
*   **顾问 Prompt 模板:**
    ```
    # Error Analysis - Task {task_id}

    ## Task Specification
    {task_content}

    ## Error Log
    {error_log}

    ## Instructions
    分析以上错误日志和任务规格，在**不修改代码**的情况下：
    1. 诊断错误的根本原因
    2. 提供具体的修复建议
    3. 如果需要，建议是否应该修改任务拆分
    ```
*   **调用方式:** `echo "<advisor_prompt>" | claude -p`
*   **输出展示:** 建议被弹窗显示在 TUI 中心，用户可选择：
    - 按 `r` 重试任务（重新执行）
    - 按 `e` 编辑任务 Markdown（修改 Prompt 或 context_files）
    - 按 `s` 跳过任务（标记为 skipped）
    - 按 `b` 标记阻塞（标记为 blocked，并填写阻塞原因）
    - 按 `q` 退出顾问模式

### 5.4 Codex 集成规范

Codex 作为**质量门控（Quality Gate）**，其 Verdict 直接决定任务的最终状态。

#### 验证流程
```
任务执行完成 (PTY exit code = 0)
      │
      ▼
┌─────────────────┐
│ status: running │ → status: verifying
└────────┬────────┘
         │
         ▼
┌─────────────────┐     ┌─────────────────┐
│ cargo check     │────►│ 编译失败        │────► status: failed
└────────┬────────┘     └─────────────────┘
         │ success
         ▼
┌─────────────────┐     ┌─────────────────┐
│ Codex Review    │────►│ Verdict: FAIL   │────► status: failed
└────────┬────────┘     └─────────────────┘
         │ PASS/WARN
         ▼
┌─────────────────────┐  ┌─────────────────┐
│ verification_cmd    │──►│ 命令失败        │────► status: failed
└─────────┬───────────┘  └─────────────────┘
          │ success
          ▼
┌───────────────────────────────────────┐
│ Verdict: PASS → status: completed     │
│ Verdict: WARN → status: needs_review  │
└───────────────────────────────────────┘
```

#### Codex 输出解析
*   **VERDICT 解析:** 使用正则 `VERDICT:\s*(PASS|FAIL|WARN)` 提取判定结果
*   **ISSUES 解析:** 使用正则 `- \[Severity: (CRITICAL|ERROR|WARN)\] (.+)` 提取具体问题
*   **WARN 策略:** 默认 `WARN` → `status: needs_review`；可在 `.claude/config.yaml` 配置 `warn_policy: needs_review|auto_complete` 覆盖。
*   **重试机制:**
    - 最大重试次数：3 次
    - 相同代码连续失败时计数
    - 超过重试限制后标记为 `status: failed` 并记录到 `.claude/status/error_history.json`

#### Codex 调用方式
```bash
# 构建审查上下文后，通过 stdin 传入指令
codex exec < review_context.txt
```

---

## 6. 总结

本产品文档定义了一个**确定性**的开发环境。

*   **ROADMAP.md** 是战略蓝图。
*   **Claude Code** 是同时负责画图（Planning）和砌砖（Execution）的工人。
*   **Rust TUI** 是严格的监工，它确保工人在干活前必须先画图（生成 Markdown），并且只有在质检合格（Tests Passed）后才能收工。

这种架构利用了 Claude Code 强大的推理能力，同时通过文件状态机约束了其不可控性，实现了高效且鲁棒的“人在回路”自动化开发。
