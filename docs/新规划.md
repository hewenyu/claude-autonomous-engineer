
---

# 产品规格说明书：基于 Markdown 状态机的确定性开发编排系统

## 1. 产品愿景与核心哲学 (Vision & Core Philosophy)

本产品是一个**“反转控制（Inversion of Control）”**的软件开发编排器。它不直接生成代码，而是作为一个**确定性的工厂管理者**，指挥 **Claude Code**（作为工人）在严格的物理约束下工作。

*   **唯一真理源 (Single Source of Truth):** 文件系统即数据库。所有的业务需求、执行计划、任务状态和运行日志都物理持久化为 **Markdown 文件**。TUI 工具无内部隐藏状态，仅作为文件系统的渲染器和自动化执行器。
*   **规划优先 (Plan-First):** 任何代码修改发生前，必须先在磁盘上生成明确的 Markdown 规划文件。**规划阶段本身也由 Claude Code 执行**，但受到 TUI 的严格提示词约束。
*   **状态隔离 (State Isolation):** 利用 PTY（伪终端）技术，每个任务启动独立的 Claude 进程。任务结束即销毁上下文，杜绝长会话导致的“上下文漂移”。

---

## 2. 文件制品协议 (Artifact Protocol)

系统严格维护项目根目录下 `.claude/` 文件夹内的文件结构。这些文件构成了系统的“状态机”。

### 2.1 战略层 (Strategy Layer)
**路径:** `.claude/status/ROADMAP.md`
*   **定义:** 项目的最高业务需求文档（Story）。
*   **生成方式:** 人工编写。
*   **Frontmatter 规范:**
    ```yaml
    type: roadmap
    status: active
    current_phase: phase-1_user_auth
    last_updated: "2023-10-27"
    ```
*   **正文内容:** 自然语言描述的 User Stories 和验收标准（Acceptance Criteria）。

### 2.2 契约层 (Contract Layer)
**路径:** `.claude/status/api_contract.yaml`
*   **定义:** 不可变的 OpenAPI/Swagger 规范。
*   **生成方式:** `utoipa` 自动生成或人工锁定。
*   **作用:** 作为质量门控（Quality Gate），所有后端修改必须通过针对此文件的 `spectral lint` 检查。

### 2.3 战术规划层 (Tactical Layer)
**路径:** `.claude/phases/<phase_id>/PHASE_PLAN.md`
*   **定义:** 一个开发里程碑的详细设计图。
*   **生成方式:** **由 Claude Code 读取 `ROADMAP.md` 后生成**。
*   **Frontmatter 规范:**
    ```yaml
    id: phase-1_user_auth
    status: in_progress # [pending, in_progress, completed]
    strategy: sequential # [sequential, parallel]
    dependencies: []
    context_focus: ["src/auth", "src/db"] # 指导 Repomix 打包范围
    ```
*   **正文内容:** 技术实现路径、架构决策记录、涉及的模块列表。

### 2.4 执行原子层 (Atomic Execution Layer)
**路径:** `.claude/phases/<phase_id>/tasks/TASK-<nnn>.md`
*   **定义:** 最小执行单元，对应一个独立的 PTY 会话。
*   **生成方式:** **由 Claude Code 读取 `PHASE_PLAN.md` 后批量生成**。
*   **Frontmatter 规范:**
    ```yaml
    id: task-001_jwt_impl
    type: code_generation # [code_generation, test_generation, refactor]
    status: pending # [pending, running, verifying, completed, failed]
    context_files: ["src/main.rs", "src/auth.rs"]
    verification_cmd: "cargo test --test auth_flow" # 必须包含验证命令
    ```
*   **正文内容:**
    1.  **Prompt:** 给 Claude 的具体指令（如“实现 JWT 签名函数”）。
    2.  **Logs:** (由 TUI 自动追加) 执行过程的 stdout/stderr 记录。

---

## 3. 核心工作流引擎 (The Workflow Engine)

TUI 基于 `Tokio` 异步运行时构建，核心是一个无限循环的状态机，通过 `notify` 监听文件变更驱动流转。

### 阶段一：智能规划 (Planning Phase)
**目标:** 将模糊的 `ROADMAP.md` 转化为具体的 `PHASE` 和 `TASK` 文件。

1.  **触发:** 用户在 TUI 中选中 `ROADMAP.md` 并按下 `p` (Plan)。
2.  **上下文构建:** TUI 调用 `tree-sitter` 生成 `repo_map.json`（代码结构图）。
3.  **Claude 调用 (Architect Mode):** TUI 启动 Claude Code 进程：
    *   **Input:** 注入 `repo_map` + `ROADMAP.md`。
    *   **System Prompt:** “你是一个架构师。请不要写代码。请根据需求，输出 `.claude/phases/` 目录下的目录结构和 Markdown 文件，确保 Frontmatter 符合规范。”
4.  **产出:** Claude 直接在磁盘上创建/更新 `PHASE_PLAN.md` 和一系列 `TASK-NNN.md` 文件。
5.  **人工审计:** TUI 刷新显示新生成的文件。此时所有任务状态为 `pending`。用户可编辑 Markdown 调整任务细节。

### 阶段二：驱动执行 (Execution Loop)
**目标:** 自动化执行所有 `pending` 状态的任务。

1.  **扫描与锁定:** TUI 发现 `TASK-NNN.md` 状态为 `pending`，将其 Frontmatter 修改为 `status: running`。
2.  **环境准备:**
    *   TUI 解析 Frontmatter 中的 `context_files`。
    *   调用 `repomix` 打包这些文件为最小上下文包 `context_bundle.xml`。
3.  **Claude 调用 (Builder Mode):** TUI 通过 `portable-pty` 启动子进程：
    ```bash
    cat context_bundle.xml | claude -p "<读取TASK.md中的Prompt并执行>"
    ```
4.  **实时渲染:** PTY 的输出流被 TUI 捕获，在界面右侧终端窗格实时显示（保留颜色）。
5.  **日志持久化:** 任务结束时，TUI 去除 ANSI 颜色码，将日志追加写入 `TASK-NNN.md` 的正文底部。

### 阶段三：双重验证 (Verification Phase)
**目标:** 确保生成的代码既符合技术规范，又符合业务需求。

1.  **状态流转:** 执行完成后，状态自动变为 `verifying`。
2.  **内环验证 (Technical Check):**
    *   执行 `cargo check` (检查编译错误)。
    *   (若涉及 API) 执行 `spectral lint .claude/status/api_contract.yaml`。
3.  **外环验证 (Business Check):**
    *   执行 Frontmatter 中定义的 `verification_cmd` (如 `cargo test`)。
4.  **决策逻辑:**
    *   **通过:** 更新 Markdown 为 `status: completed`。
    *   **失败:** 更新为 `status: failed`。TUI 自动读取 stderr 错误信息，追加到 Markdown 文件，供用户或 Advisor 分析。

---

## 4. TUI 界面规格 (Interface Specification)

界面使用 `Ratatui` 库实现立即模式渲染，分为三栏布局：

| 区域 | 组件名称 | 功能描述 |
| :--- | :--- | :--- |
| **左栏** | **State Navigator** (状态导航树) | 渲染 `.claude/` 目录树。使用颜色映射 Markdown 状态 (🔴Failed, 🟡Running, 🟢Completed, ⚪Pending)。 |
| **中栏** | **Artifact Editor** (制品编辑器) | 显示当前选中 Markdown 的内容。支持基础编辑（利用 Vim 键位）。 |
| **右栏** | **Execution Terminal** (执行终端) | 利用 `tui-term` 显示当前活跃 PTY 的输出。底部显示进度条和系统资源占用。 |

---

## 5. 关键技术实现细节 (Implementation Details)

### 5.1 "Headless" Claude 集成
为了让 Claude Code 能够被 TUI 编排，我们不使用它的交互模式，而是大量使用其 CLI 的管道能力。
*   **Prompt 注入:** 使用 `-p` 参数传递明确指令，防止 Claude 进入会话等待用户输入。
*   **输出解析:** 虽然 TUI 主要依靠文件系统变化来判断结果，但也监控 stdout 中的特定标记（如 "COMPLETED"）来作为冗余信号。

### 5.2 看门狗机制 (Watchdog)
为了防止 Claude 陷入死循环或网络超时：
*   每个 `running` 状态的任务由 `tokio::time::timeout` 包装。
*   默认超时时间为 300秒（可在 Frontmatter 中覆盖）。
*   超时触发时，TUI 发送 `SIGKILL` 强制杀掉 PTY 子进程，并将任务标记为 `Failed (Timeout)`。

### 5.3 顾问模式 (Advisor Mode)
当任务状态变为 `failed` 时，用户可按 `a` 键呼叫 Advisor。
*   **原理:** TUI 读取失败任务的 Markdown（包含 Prompt 和 错误日志），启动一个新的后台 Claude 进程。
*   **指令:** “分析以上错误日志和代码，在不修改代码的情况下，给出一个修复建议。”
*   **输出:** 建议被弹窗显示在 TUI 中心。

---

## 6. 总结

本产品文档定义了一个**确定性**的开发环境。

*   **ROADMAP.md** 是战略蓝图。
*   **Claude Code** 是同时负责画图（Planning）和砌砖（Execution）的工人。
*   **Rust TUI** 是严格的监工，它确保工人在干活前必须先画图（生成 Markdown），并且只有在质检合格（Tests Passed）后才能收工。

这种架构利用了 Claude Code 强大的推理能力，同时通过文件状态机约束了其不可控性，实现了高效且鲁棒的“人在回路”自动化开发。